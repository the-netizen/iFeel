import SwiftUI

// ---------- 1) Slice shape (sector) with configurable gap ----------
struct Wedge: Shape {
    var startDeg: Double
    var endDeg: Double
    var innerRadiusFactor: CGFloat = 0.0   // 0 = full pie; 0.6 = donut
    var gapDegrees: Double = 4.0           // visual space between slices

    func path(in rect: CGRect) -> Path {
        let c = CGPoint(x: rect.midX, y: rect.midY)
        let rOuter = min(rect.width, rect.height) * 0.5
        let rInner = rOuter * innerRadiusFactor

        // shift start/end by half the gap; 0Â° at 12 o'clock
        let g = gapDegrees * .pi / 180 / 2
        let s = (startDeg - 90) * .pi / 180 + g
        let e = (endDeg   - 90) * .pi / 180 - g

        var p = Path()
        p.addArc(center: c, radius: rOuter, startAngle: .radians(s), endAngle: .radians(e), clockwise: false)
        p.addLine(to: CGPoint(x: c.x + rInner * CGFloat(cos(e)), y: c.y + rInner * CGFloat(sin(e))))
        p.addArc(center: c, radius: rInner, startAngle: .radians(e), endAngle: .radians(s), clockwise: true)
        p.closeSubpath()
        return p
    }
}

// ---------- 2) One interactive slice ----------
struct SliceView: View {
    let index: Int
    let startDeg: Double
    let endDeg: Double
    let color: Color
    let innerFactor: CGFloat
    let gapDeg: Double
    let explodeDistance: CGFloat

    @Binding var selected: Int?   // which slice is exploded

    var body: some View {
        // mid-angle (for outward direction)
        let mid = (startDeg + endDeg) / 2
        let rad = (mid - 90) * .pi / 180
        let isSelected = selected == index

        let dx = isSelected ? explodeDistance * CGFloat(cos(rad)) : 0
        let dy = isSelected ? explodeDistance * CGFloat(sin(rad)) : 0

        Wedge(startDeg: startDeg, endDeg: endDeg,
              innerRadiusFactor: innerFactor, gapDegrees: gapDeg)
            .fill(color)
            .overlay(
                Wedge(startDeg: startDeg, endDeg: endDeg,
                      innerRadiusFactor: innerFactor, gapDegrees: gapDeg)
                    .stroke(.white.opacity(0.9), lineWidth: 1)
            )
            .offset(x: dx, y: dy) // <- independent animated movement
            .onTapGesture {
                withAnimation(.spring(response: 0.35, dampingFraction: 0.75)) {
                    selected = isSelected ? nil : index
                }
            }
    }
}

// ---------- 3) The wheel composed of independent slices ----------
struct Wheel7: View {
    private let n = 7
    private let colors: [Color] = [.pink, .orange, .yellow, .green, .mint, .blue, .purple]
    @State private var selected: Int? = nil

    // knobs you can tweak
    private let innerFactor: CGFloat = 0.0     // 0 = full pie; try 0.55 for donut
    private let gapDeg: Double = 5.0           // visual separation
    private let explode: CGFloat = 18          // how far a selected slice moves

    var body: some View {
        let step = 360.0 / Double(n)

        ZStack {
            ForEach(0..<n, id: \.self) { i in
                let start = Double(i) * step
                let end   = Double(i + 1) * step

                SliceView(index: i,
                          startDeg: start,
                          endDeg: end,
                          color: colors[i % colors.count],
                          innerFactor: innerFactor,
                          gapDeg: gapDeg,
                          explodeDistance: explode,
                          selected: $selected)
            }
        }
        .aspectRatio(1, contentMode: .fit)
        .padding()
    }
}

// ---------- 4) App entry ----------
struct ContentView: View {
    var body: some View {
        Wheel7().frame(width: 300, height: 300)
    }
}

#Preview { ContentView() }
